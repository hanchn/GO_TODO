# 第11章：性能优化

本章将深入探讨Go学生管理系统的性能优化策略，包括代码优化、数据库优化、缓存策略、并发优化和系统调优。

## 11.1 性能分析基础

### 性能指标

| 指标类型 | 关键指标 | 目标值 | 监控方法 |
|---------|---------|--------|----------|
| 🚀 **响应时间** | P95延迟 | < 200ms | APM监控 |
| 📊 **吞吐量** | QPS | > 1000 | 压力测试 |
| 💾 **内存使用** | 堆内存 | < 512MB | 内存分析 |
| 🔄 **CPU使用** | CPU利用率 | < 70% | 系统监控 |
| 🗄️ **数据库** | 查询时间 | < 50ms | 慢查询日志 |
| 🌐 **网络** | 带宽使用 | < 100MB/s | 网络监控 |

### 性能分析工具

**文件路径：** `tools/profiling.go`

```

## 11.6 Go运行时优化

### 运行时参数调优

**文件路径：** `optimizations/runtime.go`

```go
package optimizations

import (
	"fmt"
	"runtime"
	"runtime/debug"
	"time"
)

// RuntimeOptimizer 运行时优化器
type RuntimeOptimizer struct {
	gcPercent    int
	maxProcs     int
	memoryLimit  int64
	gcTargetTime time.Duration
}

// NewRuntimeOptimizer 创建运行时优化器
func NewRuntimeOptimizer() *RuntimeOptimizer {
	return &RuntimeOptimizer{
		gcPercent:    100,
		maxProcs:     runtime.NumCPU(),
		memoryLimit:  0,
		gcTargetTime: 2 * time.Millisecond,
	}
}

// OptimizeForProduction 生产环境优化
func (ro *RuntimeOptimizer) OptimizeForProduction() {
	// 设置GOMAXPROCS
	runtime.GOMAXPROCS(ro.maxProcs)
	
	// 设置GC目标百分比
	debug.SetGCPercent(ro.gcPercent)
	
	// 设置内存限制（Go 1.19+）
	if ro.memoryLimit > 0 {
		debug.SetMemoryLimit(ro.memoryLimit)
	}
	
	// 启用GC调优
	go ro.dynamicGCTuning()
}

// OptimizeForDevelopment 开发环境优化
func (ro *RuntimeOptimizer) OptimizeForDevelopment() {
	// 开发环境使用更激进的GC
	debug.SetGCPercent(50)
	
	// 启用详细的GC日志
	runtime.GC()
}

// dynamicGCTuning 动态GC调优
func (ro *RuntimeOptimizer) dynamicGCTuning() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		var m runtime.MemStats
		runtime.ReadMemStats(&m)
		
		// 根据内存使用情况调整GC
		if m.HeapInuse > m.HeapSys/2 {
			// 内存使用率高，增加GC频率
			debug.SetGCPercent(50)
		} else {
			// 内存使用率低，降低GC频率
			debug.SetGCPercent(200)
		}
	}
}

// GetRuntimeStats 获取运行时统计
func (ro *RuntimeOptimizer) GetRuntimeStats() map[string]interface{} {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	
	return map[string]interface{}{
		"goroutines":     runtime.NumGoroutine(),
		"heap_alloc":     m.HeapAlloc,
		"heap_sys":       m.HeapSys,
		"heap_inuse":     m.HeapInuse,
		"heap_released":  m.HeapReleased,
		"gc_runs":        m.NumGC,
		"gc_pause_total": m.PauseTotalNs,
		"gc_pause_avg":   m.PauseTotalNs / uint64(m.NumGC),
		"next_gc":        m.NextGC,
		"gc_percent":     debug.SetGCPercent(-1),
	}
}
```

## 11.7 性能测试

### 并发性能测试

**文件路径：** `tests/performance_test.go`

```go
package tests

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"runtime"
	"sync"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

// TestConcurrentRequests 并发请求测试
func TestConcurrentRequests(t *testing.T) {
	// 设置测试参数
	concurrency := 100
	requestsPerWorker := 10
	totalRequests := concurrency * requestsPerWorker
	
	// 创建测试服务器
	router := setupTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()
	
	// 性能指标
	var (
		successCount int64
		errorCount   int64
		totalTime    time.Duration
		mu           sync.Mutex
		wg           sync.WaitGroup
	)
	
	startTime := time.Now()
	
	// 启动并发测试
	for i := 0; i < concurrency; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			
			for j := 0; j < requestsPerWorker; j++ {
				reqStart := time.Now()
				
				// 发送请求
				resp, err := http.Get(server.URL + "/api/students")
				reqDuration := time.Since(reqStart)
				
				mu.Lock()
				if err != nil || resp.StatusCode != 200 {
					errorCount++
				} else {
					successCount++
				}
				totalTime += reqDuration
				mu.Unlock()
				
				if resp != nil {
					resp.Body.Close()
				}
			}
		}()
	}
	
	wg.Wait()
	elapsedTime := time.Since(startTime)
	
	// 计算性能指标
	qps := float64(totalRequests) / elapsedTime.Seconds()
	avgResponseTime := totalTime / time.Duration(totalRequests)
	successRate := float64(successCount) / float64(totalRequests) * 100
	
	// 输出结果
	t.Logf("并发性能测试结果:")
	t.Logf("总请求数: %d", totalRequests)
	t.Logf("并发数: %d", concurrency)
	t.Logf("成功请求: %d", successCount)
	t.Logf("失败请求: %d", errorCount)
	t.Logf("成功率: %.2f%%", successRate)
	t.Logf("QPS: %.2f", qps)
	t.Logf("平均响应时间: %v", avgResponseTime)
	t.Logf("总耗时: %v", elapsedTime)
	
	// 断言性能要求
	assert.True(t, qps > 100, "QPS应该大于100")
	assert.True(t, avgResponseTime < 100*time.Millisecond, "平均响应时间应该小于100ms")
	assert.True(t, successRate > 99, "成功率应该大于99%")
}

// BenchmarkStudentOperations 学生操作基准测试
func BenchmarkStudentOperations(b *testing.B) {
	router := setupTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()
	
	b.Run("CreateStudent", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			student := map[string]interface{}{
				"name":      fmt.Sprintf("Student%d", i),
				"student_id": fmt.Sprintf("S%06d", i),
				"email":     fmt.Sprintf("student%d@test.com", i),
				"phone":     "13800138000",
				"age":       20,
			}
			
			body, _ := json.Marshal(student)
			resp, err := http.Post(server.URL+"/api/students", "application/json", bytes.NewBuffer(body))
			if err != nil {
				b.Fatal(err)
			}
			resp.Body.Close()
		}
	})
	
	b.Run("GetStudents", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			resp, err := http.Get(server.URL + "/api/students")
			if err != nil {
				b.Fatal(err)
			}
			resp.Body.Close()
		}
	})
}

// BenchmarkMemoryUsage 内存使用基准测试
func BenchmarkMemoryUsage(b *testing.B) {
	var m1, m2 runtime.MemStats
	
	// 强制GC并获取初始内存状态
	runtime.GC()
	runtime.ReadMemStats(&m1)
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// 模拟学生数据处理
		students := make([]Student, 1000)
		for j := range students {
			students[j] = Student{
				Name:      fmt.Sprintf("Student%d", j),
				StudentID: fmt.Sprintf("S%06d", j),
				Email:     fmt.Sprintf("student%d@test.com", j),
				Phone:     "13800138000",
				Age:       20,
			}
		}
		
		// 模拟数据处理
		processStudents(students)
	}
	b.StopTimer()
	
	// 强制GC并获取最终内存状态
	runtime.GC()
	runtime.ReadMemStats(&m2)
	
	// 计算内存分配
	allocated := m2.TotalAlloc - m1.TotalAlloc
	allocationsPerOp := allocated / uint64(b.N)
	
	b.ReportMetric(float64(allocationsPerOp), "bytes/op")
	b.ReportMetric(float64(m2.Mallocs-m1.Mallocs)/float64(b.N), "allocs/op")
}

// processStudents 处理学生数据（模拟业务逻辑）
func processStudents(students []Student) {
	// 模拟数据验证和处理
	for i := range students {
		// 验证邮箱格式
		if len(students[i].Email) > 0 {
			// 简单的邮箱验证
			_ = students[i].Email
		}
		
		// 验证年龄范围
		if students[i].Age < 16 || students[i].Age > 100 {
			students[i].Age = 20 // 默认年龄
		}
	}
}
```

## 11.8 总结

### 核心特性

1. **内存优化**
   - 对象池复用
   - 零拷贝转换
   - 紧凑数据结构

2. **并发优化**
   - Worker Pool模式
   - 并发安全的Map
   - 限流器和熔断器

3. **数据库优化**
   - 查询优化
   - 索引策略
   - 连接池调优

4. **缓存管理**
   - 多级缓存
   - 缓存预热
   - 统计监控

5. **网络优化**
   - GZIP压缩
   - Keep-Alive
   - ETag缓存

6. **运行时优化**
   - GC调优
   - 内存限制
   - 动态调整

### 最佳实践

1. **性能监控**
   - 建立性能基线
   - 持续监控关键指标
   - 定期性能测试

2. **优化策略**
   - 先测量再优化
   - 关注热点代码
   - 平衡复杂度和性能

3. **资源管理**
   - 合理设置连接池
   - 及时释放资源
   - 避免内存泄漏

4. **并发控制**
   - 合理控制并发数
   - 避免过度并发
   - 使用适当的同步机制

通过这些优化技术，可以显著提升Go应用的性能和稳定性。go
package tools

import (
	"context"
	"fmt"
	"net/http"
	_ "net/http/pprof"
	"os"
	"runtime"
	"runtime/pprof"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

// ProfileConfig 性能分析配置
type ProfileConfig struct {
	Enabled    bool   `json:"enabled"`
	Port       string `json:"port"`
	CPUProfile string `json:"cpu_profile"`
	MemProfile string `json:"mem_profile"`
}

// ProfileManager 性能分析管理器
type ProfileManager struct {
	config ProfileConfig
	server *http.Server
}

// NewProfileManager 创建性能分析管理器
func NewProfileManager(config ProfileConfig) *ProfileManager {
	return &ProfileManager{
		config: config,
	}
}

// Start 启动性能分析服务
func (pm *ProfileManager) Start() error {
	if !pm.config.Enabled {
		return nil
	}

	// 启动pprof服务
	mux := http.NewServeMux()
	mux.HandleFunc("/debug/pprof/", http.HandlerFunc(pprof.Index))
	mux.HandleFunc("/debug/pprof/cmdline", http.HandlerFunc(pprof.Cmdline))
	mux.HandleFunc("/debug/pprof/profile", http.HandlerFunc(pprof.Profile))
	mux.HandleFunc("/debug/pprof/symbol", http.HandlerFunc(pprof.Symbol))
	mux.HandleFunc("/debug/pprof/trace", http.HandlerFunc(pprof.Trace))

	pm.server = &http.Server{
		Addr:    ":" + pm.config.Port,
		Handler: mux,
	}

	go func() {
		logrus.Infof("性能分析服务启动在端口 %s", pm.config.Port)
		if err := pm.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logrus.Errorf("性能分析服务启动失败: %v", err)
		}
	}()

	return nil
}

// Stop 停止性能分析服务
func (pm *ProfileManager) Stop() error {
	if pm.server == nil {
		return nil
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	return pm.server.Shutdown(ctx)
}

// StartCPUProfile 开始CPU性能分析
func (pm *ProfileManager) StartCPUProfile() error {
	if pm.config.CPUProfile == "" {
		return fmt.Errorf("CPU profile文件路径未配置")
	}

	f, err := os.Create(pm.config.CPUProfile)
	if err != nil {
		return fmt.Errorf("创建CPU profile文件失败: %v", err)
	}

	if err := pprof.StartCPUProfile(f); err != nil {
		f.Close()
		return fmt.Errorf("启动CPU profile失败: %v", err)
	}

	logrus.Infof("CPU性能分析已启动，输出文件: %s", pm.config.CPUProfile)
	return nil
}

// StopCPUProfile 停止CPU性能分析
func (pm *ProfileManager) StopCPUProfile() {
	pprof.StopCPUProfile()
	logrus.Info("CPU性能分析已停止")
}

// WriteMemProfile 写入内存性能分析
func (pm *ProfileManager) WriteMemProfile() error {
	if pm.config.MemProfile == "" {
		return fmt.Errorf("内存profile文件路径未配置")
	}

	f, err := os.Create(pm.config.MemProfile)
	if err != nil {
		return fmt.Errorf("创建内存profile文件失败: %v", err)
	}
	defer f.Close()

	runtime.GC() // 强制垃圾回收
	if err := pprof.WriteHeapProfile(f); err != nil {
		return fmt.Errorf("写入内存profile失败: %v", err)
	}

	logrus.Infof("内存性能分析已保存到: %s", pm.config.MemProfile)
	return nil
}

// MemoryStats 内存统计信息
type MemoryStats struct {
	Alloc        uint64 `json:"alloc"`         // 当前分配的内存
	TotalAlloc   uint64 `json:"total_alloc"`   // 总分配的内存
	Sys          uint64 `json:"sys"`           // 系统内存
	Lookups      uint64 `json:"lookups"`       // 查找次数
	Mallocs      uint64 `json:"mallocs"`       // 分配次数
	Frees        uint64 `json:"frees"`         // 释放次数
	HeapAlloc    uint64 `json:"heap_alloc"`    // 堆分配
	HeapSys      uint64 `json:"heap_sys"`      // 堆系统内存
	HeapIdle     uint64 `json:"heap_idle"`     // 堆空闲内存
	HeapInuse    uint64 `json:"heap_inuse"`    // 堆使用内存
	HeapReleased uint64 `json:"heap_released"` // 堆释放内存
	HeapObjects  uint64 `json:"heap_objects"`  // 堆对象数
	StackInuse   uint64 `json:"stack_inuse"`   // 栈使用内存
	StackSys     uint64 `json:"stack_sys"`     // 栈系统内存
	MSpanInuse   uint64 `json:"mspan_inuse"`   // MSpan使用内存
	MSpanSys     uint64 `json:"mspan_sys"`     // MSpan系统内存
	MCacheInuse  uint64 `json:"mcache_inuse"`  // MCache使用内存
	MCacheSys    uint64 `json:"mcache_sys"`    // MCache系统内存
	GCSys        uint64 `json:"gc_sys"`        // GC系统内存
	OtherSys     uint64 `json:"other_sys"`     // 其他系统内存
	NextGC       uint64 `json:"next_gc"`       // 下次GC阈值
	LastGC       uint64 `json:"last_gc"`       // 上次GC时间
	NumGC        uint32 `json:"num_gc"`        // GC次数
	NumForcedGC  uint32 `json:"num_forced_gc"` // 强制GC次数
	GCCPUFraction float64 `json:"gc_cpu_fraction"` // GC CPU占比
}

// GetMemoryStats 获取内存统计信息
func GetMemoryStats() MemoryStats {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	return MemoryStats{
		Alloc:         m.Alloc,
		TotalAlloc:    m.TotalAlloc,
		Sys:           m.Sys,
		Lookups:       m.Lookups,
		Mallocs:       m.Mallocs,
		Frees:         m.Frees,
		HeapAlloc:     m.HeapAlloc,
		HeapSys:       m.HeapSys,
		HeapIdle:      m.HeapIdle,
		HeapInuse:     m.HeapInuse,
		HeapReleased:  m.HeapReleased,
		HeapObjects:   m.HeapObjects,
		StackInuse:    m.StackInuse,
		StackSys:      m.StackSys,
		MSpanInuse:    m.MSpanInuse,
		MSpanSys:      m.MSpanSys,
		MCacheInuse:   m.MCacheInuse,
		MCacheSys:     m.MCacheSys,
		GCSys:         m.GCSys,
		OtherSys:      m.OtherSys,
		NextGC:        m.NextGC,
		LastGC:        m.LastGC,
		NumGC:         m.NumGC,
		NumForcedGC:   m.NumForcedGC,
		GCCPUFraction: m.GCCPUFraction,
	}
}

// PerformanceMiddleware 性能监控中间件
func PerformanceMiddleware() gin.HandlerFunc {
	return gin.HandlerFunc(func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		method := c.Request.Method

		// 处理请求
		c.Next()

		// 计算处理时间
		duration := time.Since(start)
		status := c.Writer.Status()

		// 记录性能指标
		logrus.WithFields(logrus.Fields{
			"method":   method,
			"path":     path,
			"status":   status,
			"duration": duration.Milliseconds(),
			"size":     c.Writer.Size(),
		}).Info("请求处理完成")

		// 慢请求告警
		if duration > 1*time.Second {
			logrus.WithFields(logrus.Fields{
				"method":   method,
				"path":     path,
				"duration": duration.Milliseconds(),
			}).Warn("慢请求检测")
		}
	})
}

// BenchmarkTest 基准测试
type BenchmarkTest struct {
	Name     string
	Function func() error
	Runs     int
}

// RunBenchmark 运行基准测试
func RunBenchmark(tests []BenchmarkTest) {
	for _, test := range tests {
		logrus.Infof("开始基准测试: %s", test.Name)
		
		start := time.Now()
		var totalDuration time.Duration
		var errors int

		for i := 0; i < test.Runs; i++ {
			runStart := time.Now()
			if err := test.Function(); err != nil {
				errors++
				logrus.Errorf("基准测试错误: %v", err)
			}
			totalDuration += time.Since(runStart)
		}

		totalTime := time.Since(start)
		avgDuration := totalDuration / time.Duration(test.Runs)
		successRate := float64(test.Runs-errors) / float64(test.Runs) * 100

		logrus.WithFields(logrus.Fields{
			"test":         test.Name,
			"runs":         test.Runs,
			"total_time":   totalTime.Milliseconds(),
			"avg_duration": avgDuration.Milliseconds(),
			"success_rate": successRate,
			"errors":       errors,
		}).Info("基准测试完成")
	}
}
```

## 11.2 代码优化

### 内存优化

**文件路径：** `optimizations/memory.go`

```go
package optimizations

import (
	"sync"
	"unsafe"
)

// ObjectPool 对象池
type ObjectPool struct {
	pool sync.Pool
	new  func() interface{}
}

// NewObjectPool 创建对象池
func NewObjectPool(newFunc func() interface{}) *ObjectPool {
	return &ObjectPool{
		pool: sync.Pool{
			New: newFunc,
		},
		new: newFunc,
	}
}

// Get 获取对象
func (p *ObjectPool) Get() interface{} {
	return p.pool.Get()
}

// Put 归还对象
func (p *ObjectPool) Put(obj interface{}) {
	p.pool.Put(obj)
}

// StringPool 字符串池
var StringPool = NewObjectPool(func() interface{} {
	return make([]byte, 0, 1024)
})

// SlicePool 切片池
var SlicePool = NewObjectPool(func() interface{} {
	return make([]interface{}, 0, 100)
})

// MapPool Map池
var MapPool = NewObjectPool(func() interface{} {
	return make(map[string]interface{}, 100)
})

// BytesToString 零拷贝字节转字符串
func BytesToString(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}

// StringToBytes 零拷贝字符串转字节
func StringToBytes(s string) []byte {
	return *(*[]byte)(unsafe.Pointer(
		&struct {
			string
			Cap int
		}{s, len(s)},
	))
}

// PreallocatedSlice 预分配切片
type PreallocatedSlice struct {
	data []interface{}
	len  int
	cap  int
}

// NewPreallocatedSlice 创建预分配切片
func NewPreallocatedSlice(capacity int) *PreallocatedSlice {
	return &PreallocatedSlice{
		data: make([]interface{}, 0, capacity),
		cap:  capacity,
	}
}

// Append 添加元素
func (ps *PreallocatedSlice) Append(item interface{}) {
	if ps.len < ps.cap {
		ps.data = append(ps.data, item)
		ps.len++
	}
}

// Reset 重置切片
func (ps *PreallocatedSlice) Reset() {
	ps.data = ps.data[:0]
	ps.len = 0
}

// Get 获取元素
func (ps *PreallocatedSlice) Get(index int) interface{} {
	if index < ps.len {
		return ps.data[index]
	}
	return nil
}

// Len 获取长度
func (ps *PreallocatedSlice) Len() int {
	return ps.len
}

// MemoryOptimizedStudent 内存优化的学生结构
type MemoryOptimizedStudent struct {
	ID       uint32 // 使用uint32而不是uint64
	Name     string
	Age      uint8  // 使用uint8而不是int
	Gender   bool   // 使用bool而不是string
	Email    string
	Phone    string
	Address  string
	Grade    uint8
	Class    uint8
	Status   uint8
	// 使用位字段可以进一步优化
}

// Size 计算结构体大小
func (s *MemoryOptimizedStudent) Size() uintptr {
	return unsafe.Sizeof(*s)
}

// CompactStudent 紧凑的学生结构（使用位字段）
type CompactStudent struct {
	ID      uint32
	Name    string
	Email   string
	Phone   string
	Address string
	// 将多个小字段打包到一个uint32中
	Packed uint32 // Age(8) + Gender(1) + Grade(8) + Class(8) + Status(7)
}

// SetAge 设置年龄
func (cs *CompactStudent) SetAge(age uint8) {
	cs.Packed = (cs.Packed &^ 0xFF) | uint32(age)
}

// GetAge 获取年龄
func (cs *CompactStudent) GetAge() uint8 {
	return uint8(cs.Packed & 0xFF)
}

// SetGender 设置性别
func (cs *CompactStudent) SetGender(isMale bool) {
	if isMale {
		cs.Packed |= 1 << 8
	} else {
		cs.Packed &^= 1 << 8
	}
}

// GetGender 获取性别
func (cs *CompactStudent) GetGender() bool {
	return (cs.Packed>>8)&1 == 1
}

// SetGrade 设置年级
func (cs *CompactStudent) SetGrade(grade uint8) {
	cs.Packed = (cs.Packed &^ (0xFF << 9)) | (uint32(grade) << 9)
}

// GetGrade 获取年级
func (cs *CompactStudent) GetGrade() uint8 {
	return uint8((cs.Packed >> 9) & 0xFF)
}

// SetClass 设置班级
func (cs *CompactStudent) SetClass(class uint8) {
	cs.Packed = (cs.Packed &^ (0xFF << 17)) | (uint32(class) << 17)
}

// GetClass 获取班级
func (cs *CompactStudent) GetClass() uint8 {
	return uint8((cs.Packed >> 17) & 0xFF)
}

// SetStatus 设置状态
func (cs *CompactStudent) SetStatus(status uint8) {
	cs.Packed = (cs.Packed &^ (0x7F << 25)) | (uint32(status&0x7F) << 25)
}

// GetStatus 获取状态
func (cs *CompactStudent) GetStatus() uint8 {
	return uint8((cs.Packed >> 25) & 0x7F)
}
```

### 并发优化

**文件路径：** `optimizations/concurrency.go`

```go
package optimizations

import (
	"context"
	"runtime"
	"sync"
	"time"
)

// WorkerPool 工作池
type WorkerPool struct {
	workerCount int
	jobQueue    chan Job
	workers     []*Worker
	wg          sync.WaitGroup
	ctx         context.Context
	cancel      context.CancelFunc
}

// Job 工作任务
type Job interface {
	Execute() error
}

// Worker 工作者
type Worker struct {
	id       int
	jobQueue chan Job
	quit     chan bool
}

// NewWorkerPool 创建工作池
func NewWorkerPool(workerCount, queueSize int) *WorkerPool {
	ctx, cancel := context.WithCancel(context.Background())
	return &WorkerPool{
		workerCount: workerCount,
		jobQueue:    make(chan Job, queueSize),
		workers:     make([]*Worker, workerCount),
		ctx:         ctx,
		cancel:      cancel,
	}
}

// Start 启动工作池
func (wp *WorkerPool) Start() {
	for i := 0; i < wp.workerCount; i++ {
		worker := &Worker{
			id:       i,
			jobQueue: wp.jobQueue,
			quit:     make(chan bool),
		}
		wp.workers[i] = worker
		wp.wg.Add(1)
		go wp.runWorker(worker)
	}
}

// Stop 停止工作池
func (wp *WorkerPool) Stop() {
	wp.cancel()
	close(wp.jobQueue)
	wp.wg.Wait()
}

// Submit 提交任务
func (wp *WorkerPool) Submit(job Job) bool {
	select {
	case wp.jobQueue <- job:
		return true
	case <-wp.ctx.Done():
		return false
	default:
		return false
	}
}

// runWorker 运行工作者
func (wp *WorkerPool) runWorker(worker *Worker) {
	defer wp.wg.Done()
	for {
		select {
		case job := <-worker.jobQueue:
			if job != nil {
				job.Execute()
			}
		case <-wp.ctx.Done():
			return
		}
	}
}

// ConcurrentMap 并发安全的Map
type ConcurrentMap struct {
	shards []*MapShard
	count  int
}

// MapShard Map分片
type MapShard struct {
	mu    sync.RWMutex
	items map[string]interface{}
}

// NewConcurrentMap 创建并发Map
func NewConcurrentMap(shardCount int) *ConcurrentMap {
	if shardCount <= 0 {
		shardCount = runtime.NumCPU()
	}
	
	cm := &ConcurrentMap{
		shards: make([]*MapShard, shardCount),
		count:  shardCount,
	}
	
	for i := 0; i < shardCount; i++ {
		cm.shards[i] = &MapShard{
			items: make(map[string]interface{}),
		}
	}
	
	return cm
}

// getShard 获取分片
func (cm *ConcurrentMap) getShard(key string) *MapShard {
	hash := fnv32(key)
	return cm.shards[hash%uint32(cm.count)]
}

// Set 设置值
func (cm *ConcurrentMap) Set(key string, value interface{}) {
	shard := cm.getShard(key)
	shard.mu.Lock()
	shard.items[key] = value
	shard.mu.Unlock()
}

// Get 获取值
func (cm *ConcurrentMap) Get(key string) (interface{}, bool) {
	shard := cm.getShard(key)
	shard.mu.RLock()
	value, ok := shard.items[key]
	shard.mu.RUnlock()
	return value, ok
}

// Delete 删除值
func (cm *ConcurrentMap) Delete(key string) {
	shard := cm.getShard(key)
	shard.mu.Lock()
	delete(shard.items, key)
	shard.mu.Unlock()
}

// Keys 获取所有键
func (cm *ConcurrentMap) Keys() []string {
	var keys []string
	for _, shard := range cm.shards {
		shard.mu.RLock()
		for key := range shard.items {
			keys = append(keys, key)
		}
		shard.mu.RUnlock()
	}
	return keys
}

// fnv32 FNV-1a 32位哈希函数
func fnv32(key string) uint32 {
	hash := uint32(2166136261)
	const prime32 = uint32(16777619)
	for i := 0; i < len(key); i++ {
		hash ^= uint32(key[i])
		hash *= prime32
	}
	return hash
}

// RateLimiter 限流器
type RateLimiter struct {
	rate     int
	burst    int
	tokens   int
	lastTime time.Time
	mu       sync.Mutex
}

// NewRateLimiter 创建限流器
func NewRateLimiter(rate, burst int) *RateLimiter {
	return &RateLimiter{
		rate:     rate,
		burst:    burst,
		tokens:   burst,
		lastTime: time.Now(),
	}
}

// Allow 检查是否允许请求
func (rl *RateLimiter) Allow() bool {
	rl.mu.Lock()
	defer rl.mu.Unlock()
	
	now := time.Now()
	elapsed := now.Sub(rl.lastTime)
	rl.lastTime = now
	
	// 添加令牌
	tokensToAdd := int(elapsed.Seconds() * float64(rl.rate))
	rl.tokens += tokensToAdd
	if rl.tokens > rl.burst {
		rl.tokens = rl.burst
	}
	
	// 消费令牌
	if rl.tokens > 0 {
		rl.tokens--
		return true
	}
	
	return false
}

// CircuitBreaker 熔断器
type CircuitBreaker struct {
	maxFailures  int
	resetTimeout time.Duration
	state        CircuitState
	failures     int
	lastFailTime time.Time
	mu           sync.RWMutex
}

// CircuitState 熔断器状态
type CircuitState int

const (
	StateClosed CircuitState = iota
	StateOpen
	StateHalfOpen
)

// NewCircuitBreaker 创建熔断器
func NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {
	return &CircuitBreaker{
		maxFailures:  maxFailures,
		resetTimeout: resetTimeout,
		state:        StateClosed,
	}
}

// Call 执行调用
func (cb *CircuitBreaker) Call(fn func() error) error {
	if !cb.allowRequest() {
		return ErrCircuitOpen
	}
	
	err := fn()
	cb.recordResult(err == nil)
	return err
}

// allowRequest 检查是否允许请求
func (cb *CircuitBreaker) allowRequest() bool {
	cb.mu.RLock()
	defer cb.mu.RUnlock()
	
	switch cb.state {
	case StateClosed:
		return true
	case StateOpen:
		return time.Since(cb.lastFailTime) > cb.resetTimeout
	case StateHalfOpen:
		return true
	default:
		return false
	}
}

// recordResult 记录结果
func (cb *CircuitBreaker) recordResult(success bool) {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	
	if success {
		cb.onSuccess()
	} else {
		cb.onFailure()
	}
}

// onSuccess 成功处理
func (cb *CircuitBreaker) onSuccess() {
	cb.failures = 0
	if cb.state == StateHalfOpen {
		cb.state = StateClosed
	}
}

// onFailure 失败处理
func (cb *CircuitBreaker) onFailure() {
	cb.failures++
	cb.lastFailTime = time.Now()
	
	if cb.failures >= cb.maxFailures {
		cb.state = StateOpen
	} else if cb.state == StateHalfOpen {
		cb.state = StateOpen
	}
}

// ErrCircuitOpen 熔断器开启错误
var ErrCircuitOpen = fmt.Errorf("circuit breaker is open")
```

## 11.3 数据库优化

### 查询优化

**文件路径：** `optimizations/database.go`

```go
package optimizations

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// QueryOptimizer 查询优化器
type QueryOptimizer struct {
	db *gorm.DB
}

// NewQueryOptimizer 创建查询优化器
func NewQueryOptimizer(db *gorm.DB) *QueryOptimizer {
	return &QueryOptimizer{db: db}
}

// OptimizedStudentQuery 优化的学生查询
type OptimizedStudentQuery struct {
	db    *gorm.DB
	cache map[string]interface{}
}

// NewOptimizedStudentQuery 创建优化的学生查询
func NewOptimizedStudentQuery(db *gorm.DB) *OptimizedStudentQuery {
	return &OptimizedStudentQuery{
		db:    db,
		cache: make(map[string]interface{}),
	}
}

// GetStudentsByGradeOptimized 优化的按年级查询学生
func (osq *OptimizedStudentQuery) GetStudentsByGradeOptimized(grade int, limit, offset int) ([]Student, error) {
	// 使用索引优化查询
	var students []Student
	err := osq.db.Where("grade = ? AND deleted_at IS NULL", grade).
		Select("id, name, age, gender, email, grade, class"). // 只选择需要的字段
		Order("id"). // 使用主键排序，利用聚簇索引
		Limit(limit).
		Offset(offset).
		Find(&students).Error
	
	return students, err
}

// BatchGetStudents 批量获取学生
func (osq *OptimizedStudentQuery) BatchGetStudents(ids []uint) ([]Student, error) {
	if len(ids) == 0 {
		return nil, nil
	}
	
	// 使用IN查询，但限制批次大小
	const batchSize = 1000
	var allStudents []Student
	
	for i := 0; i < len(ids); i += batchSize {
		end := i + batchSize
		if end > len(ids) {
			end = len(ids)
		}
		
		var batchStudents []Student
		err := osq.db.Where("id IN ? AND deleted_at IS NULL", ids[i:end]).
			Find(&batchStudents).Error
		if err != nil {
			return nil, err
		}
		
		allStudents = append(allStudents, batchStudents...)
	}
	
	return allStudents, nil
}

// SearchStudentsOptimized 优化的学生搜索
func (osq *OptimizedStudentQuery) SearchStudentsOptimized(keyword string, limit, offset int) ([]Student, error) {
	if keyword == "" {
		return osq.GetAllStudentsOptimized(limit, offset)
	}
	
	// 使用全文索引搜索（如果支持）
	var students []Student
	keyword = "%" + keyword + "%"
	
	// 优先搜索精确匹配
	err := osq.db.Where("(name LIKE ? OR email LIKE ? OR phone LIKE ?) AND deleted_at IS NULL", keyword, keyword, keyword).
		Select("id, name, age, gender, email, phone, grade, class").
		Order("CASE WHEN name = ? THEN 1 WHEN name LIKE ? THEN 2 ELSE 3 END, id", strings.Trim(keyword, "%"), keyword).
		Limit(limit).
		Offset(offset).
		Find(&students).Error
	
	return students, err
}

// GetAllStudentsOptimized 优化的获取所有学生
func (osq *OptimizedStudentQuery) GetAllStudentsOptimized(limit, offset int) ([]Student, error) {
	var students []Student
	err := osq.db.Where("deleted_at IS NULL").
		Select("id, name, age, gender, email, phone, grade, class, created_at").
		Order("id").
		Limit(limit).
		Offset(offset).
		Find(&students).Error
	
	return students, err
}

// GetStudentStatistics 获取学生统计信息（优化版）
func (osq *OptimizedStudentQuery) GetStudentStatistics() (map[string]interface{}, error) {
	type StatResult struct {
		TotalCount   int64 `json:"total_count"`
		MaleCount    int64 `json:"male_count"`
		FemaleCount  int64 `json:"female_count"`
		AvgAge       float64 `json:"avg_age"`
		GradeCount   int64 `json:"grade_count"`
	}
	
	// 使用单个查询获取所有统计信息
	var result StatResult
	err := osq.db.Model(&Student{}).
		Select(`
			COUNT(*) as total_count,
			SUM(CASE WHEN gender = 'male' THEN 1 ELSE 0 END) as male_count,
			SUM(CASE WHEN gender = 'female' THEN 1 ELSE 0 END) as female_count,
			AVG(age) as avg_age,
			COUNT(DISTINCT grade) as grade_count
		`).
		Where("deleted_at IS NULL").
		Scan(&result).Error
	
	if err != nil {
		return nil, err
	}
	
	return map[string]interface{}{
		"total_count":  result.TotalCount,
		"male_count":   result.MaleCount,
		"female_count": result.FemaleCount,
		"avg_age":      result.AvgAge,
		"grade_count":  result.GradeCount,
	}, nil
}

// DatabaseOptimizer 数据库优化器
type DatabaseOptimizer struct {
	db *gorm.DB
}

// NewDatabaseOptimizer 创建数据库优化器
func NewDatabaseOptimizer(db *gorm.DB) *DatabaseOptimizer {
	return &DatabaseOptimizer{db: db}
}

// CreateIndexes 创建优化索引
func (do *DatabaseOptimizer) CreateIndexes() error {
	// 为学生表创建复合索引
	indexes := []string{
		"CREATE INDEX IF NOT EXISTS idx_students_grade_class ON students(grade, class)",
		"CREATE INDEX IF NOT EXISTS idx_students_name ON students(name)",
		"CREATE INDEX IF NOT EXISTS idx_students_email ON students(email)",
		"CREATE INDEX IF NOT EXISTS idx_students_phone ON students(phone)",
		"CREATE INDEX IF NOT EXISTS idx_students_deleted_at ON students(deleted_at)",
		"CREATE INDEX IF NOT EXISTS idx_students_created_at ON students(created_at)",
		"CREATE INDEX IF NOT EXISTS idx_students_grade_deleted ON students(grade, deleted_at)",
		"CREATE INDEX IF NOT EXISTS idx_students_class_deleted ON students(class, deleted_at)",
	}
	
	for _, indexSQL := range indexes {
		if err := do.db.Exec(indexSQL).Error; err != nil {
			return fmt.Errorf("创建索引失败: %v", err)
		}
	}
	
	return nil
}

// AnalyzeQueries 分析慢查询
func (do *DatabaseOptimizer) AnalyzeQueries() error {
	// 启用慢查询日志
	do.db.Logger = logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags),
		logger.Config{
			SlowThreshold: 100 * time.Millisecond, // 慢查询阈值
			LogLevel:      logger.Warn,
			Colorful:      true,
		},
	)
	
	return nil
}

// OptimizeTableStructure 优化表结构
func (do *DatabaseOptimizer) OptimizeTableStructure() error {
	// 分析表并优化
	tables := []string{"students"}
	
	for _, table := range tables {
		// MySQL特定的优化
		if err := do.db.Exec(fmt.Sprintf("ANALYZE TABLE %s", table)).Error; err != nil {
			return fmt.Errorf("分析表 %s 失败: %v", table, err)
		}
		
		// 优化表
		if err := do.db.Exec(fmt.Sprintf("OPTIMIZE TABLE %s", table)).Error; err != nil {
			return fmt.Errorf("优化表 %s 失败: %v", table, err)
		}
	}
	
	return nil
}

// ConnectionPoolOptimizer 连接池优化器
type ConnectionPoolOptimizer struct {
	db *gorm.DB
}

// NewConnectionPoolOptimizer 创建连接池优化器
func NewConnectionPoolOptimizer(db *gorm.DB) *ConnectionPoolOptimizer {
	return &ConnectionPoolOptimizer{db: db}
}

// OptimizeConnectionPool 优化连接池
func (cpo *ConnectionPoolOptimizer) OptimizeConnectionPool() error {
	sqlDB, err := cpo.db.DB()
	if err != nil {
		return err
	}
	
	// 设置最大打开连接数
	sqlDB.SetMaxOpenConns(100)
	
	// 设置最大空闲连接数
	sqlDB.SetMaxIdleConns(10)
	
	// 设置连接最大生存时间
	sqlDB.SetConnMaxLifetime(time.Hour)
	
	// 设置连接最大空闲时间
	sqlDB.SetConnMaxIdleTime(time.Minute * 10)
	
	return nil
}

// GetConnectionStats 获取连接池统计信息
func (cpo *ConnectionPoolOptimizer) GetConnectionStats() (sql.DBStats, error) {
	sqlDB, err := cpo.db.DB()
	if err != nil {
		return sql.DBStats{}, err
	}
	
	return sqlDB.Stats(), nil
}

// PreparedStatementCache 预编译语句缓存
type PreparedStatementCache struct {
	db         *gorm.DB
	statements map[string]*sql.Stmt
	mu         sync.RWMutex
}

// NewPreparedStatementCache 创建预编译语句缓存
func NewPreparedStatementCache(db *gorm.DB) *PreparedStatementCache {
	return &PreparedStatementCache{
		db:         db,
		statements: make(map[string]*sql.Stmt),
	}
}

// GetStatement 获取预编译语句
func (psc *PreparedStatementCache) GetStatement(query string) (*sql.Stmt, error) {
	psc.mu.RLock()
	stmt, exists := psc.statements[query]
	psc.mu.RUnlock()
	
	if exists {
		return stmt, nil
	}
	
	psc.mu.Lock()
	defer psc.mu.Unlock()
	
	// 双重检查
	if stmt, exists := psc.statements[query]; exists {
		return stmt, nil
	}
	
	// 创建预编译语句
	sqlDB, err := psc.db.DB()
	if err != nil {
		return nil, err
	}
	
	stmt, err = sqlDB.Prepare(query)
	if err != nil {
		return nil, err
	}
	
	psc.statements[query] = stmt
	return stmt, nil
}

// Close 关闭所有预编译语句
func (psc *PreparedStatementCache) Close() error {
	psc.mu.Lock()
	defer psc.mu.Unlock()
	
	for _, stmt := range psc.statements {
		stmt.Close()
	}
	
	psc.statements = make(map[string]*sql.Stmt)
	return nil
}
```

## 11.4 缓存优化

### 多级缓存

**文件路径：** `optimizations/cache.go`

```go
package optimizations

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/go-redis/redis/v8"
)

// CacheLevel 缓存级别
type CacheLevel int

const (
	L1Cache CacheLevel = iota // 内存缓存
	L2Cache                   // Redis缓存
	L3Cache                   // 数据库
)

// MultiLevelCache 多级缓存
type MultiLevelCache struct {
	l1Cache *LRUCache
	l2Cache *redis.Client
	ctx     context.Context
}

// NewMultiLevelCache 创建多级缓存
func NewMultiLevelCache(l1Size int, redisClient *redis.Client) *MultiLevelCache {
	return &MultiLevelCache{
		l1Cache: NewLRUCache(l1Size),
		l2Cache: redisClient,
		ctx:     context.Background(),
	}
}

// Get 获取缓存值
func (mlc *MultiLevelCache) Get(key string) (interface{}, bool) {
	// L1缓存查找
	if value, ok := mlc.l1Cache.Get(key); ok {
		return value, true
	}
	
	// L2缓存查找
	if mlc.l2Cache != nil {
		val, err := mlc.l2Cache.Get(mlc.ctx, key).Result()
		if err == nil {
			var value interface{}
			if err := json.Unmarshal([]byte(val), &value); err == nil {
				// 回填L1缓存
				mlc.l1Cache.Set(key, value, time.Minute*5)
				return value, true
			}
		}
	}
	
	return nil, false
}

// Set 设置缓存值
func (mlc *MultiLevelCache) Set(key string, value interface{}, ttl time.Duration) error {
	// 设置L1缓存
	mlc.l1Cache.Set(key, value, ttl)
	
	// 设置L2缓存
	if mlc.l2Cache != nil {
		data, err := json.Marshal(value)
		if err != nil {
			return err
		}
		return mlc.l2Cache.Set(mlc.ctx, key, data, ttl).Err()
	}
	
	return nil
}

// Delete 删除缓存值
func (mlc *MultiLevelCache) Delete(key string) error {
	// 删除L1缓存
	mlc.l1Cache.Delete(key)
	
	// 删除L2缓存
	if mlc.l2Cache != nil {
		return mlc.l2Cache.Del(mlc.ctx, key).Err()
	}
	
	return nil
}

// LRUCache LRU缓存实现
type LRUCache struct {
	capacity int
	cache    map[string]*CacheNode
	head     *CacheNode
	tail     *CacheNode
	mu       sync.RWMutex
}

// CacheNode 缓存节点
type CacheNode struct {
	key       string
	value     interface{}
	expireAt  time.Time
	prev      *CacheNode
	next      *CacheNode
}

// NewLRUCache 创建LRU缓存
func NewLRUCache(capacity int) *LRUCache {
	cache := &LRUCache{
		capacity: capacity,
		cache:    make(map[string]*CacheNode),
		head:     &CacheNode{},
		tail:     &CacheNode{},
	}
	
	cache.head.next = cache.tail
	cache.tail.prev = cache.head
	
	// 启动清理过期数据的goroutine
	go cache.cleanupExpired()
	
	return cache
}

// Get 获取值
func (lru *LRUCache) Get(key string) (interface{}, bool) {
	lru.mu.Lock()
	defer lru.mu.Unlock()
	
	node, exists := lru.cache[key]
	if !exists {
		return nil, false
	}
	
	// 检查是否过期
	if time.Now().After(node.expireAt) {
		lru.removeNode(node)
		delete(lru.cache, key)
		return nil, false
	}
	
	// 移动到头部
	lru.moveToHead(node)
	return node.value, true
}

// Set 设置值
func (lru *LRUCache) Set(key string, value interface{}, ttl time.Duration) {
	lru.mu.Lock()
	defer lru.mu.Unlock()
	
	if node, exists := lru.cache[key]; exists {
		// 更新现有节点
		node.value = value
		node.expireAt = time.Now().Add(ttl)
		lru.moveToHead(node)
	} else {
		// 创建新节点
		newNode := &CacheNode{
			key:      key,
			value:    value,
			expireAt: time.Now().Add(ttl),
		}
		
		lru.cache[key] = newNode
		lru.addToHead(newNode)
		
		// 检查容量
		if len(lru.cache) > lru.capacity {
			tail := lru.removeTail()
			delete(lru.cache, tail.key)
		}
	}
}

// Delete 删除值
func (lru *LRUCache) Delete(key string) {
	lru.mu.Lock()
	defer lru.mu.Unlock()
	
	if node, exists := lru.cache[key]; exists {
		lru.removeNode(node)
		delete(lru.cache, key)
	}
}

// addToHead 添加到头部
func (lru *LRUCache) addToHead(node *CacheNode) {
	node.prev = lru.head
	node.next = lru.head.next
	lru.head.next.prev = node
	lru.head.next = node
}

// removeNode 移除节点
func (lru *LRUCache) removeNode(node *CacheNode) {
	node.prev.next = node.next
	node.next.prev = node.prev
}

// moveToHead 移动到头部
func (lru *LRUCache) moveToHead(node *CacheNode) {
	lru.removeNode(node)
	lru.addToHead(node)
}

// removeTail 移除尾部
func (lru *LRUCache) removeTail() *CacheNode {
	last := lru.tail.prev
	lru.removeNode(last)
	return last
}

// cleanupExpired 清理过期数据
func (lru *LRUCache) cleanupExpired() {
	ticker := time.NewTicker(time.Minute)
	defer ticker.Stop()
	
	for range ticker.C {
		lru.mu.Lock()
		now := time.Now()
		expiredKeys := make([]string, 0)
		
		for key, node := range lru.cache {
			if now.After(node.expireAt) {
				expiredKeys = append(expiredKeys, key)
			}
		}
		
		for _, key := range expiredKeys {
			node := lru.cache[key]
			lru.removeNode(node)
			delete(lru.cache, key)
		}
		lru.mu.Unlock()
	}
}

// CacheManager 缓存管理器
type CacheManager struct {
	cache     *MultiLevelCache
	stats     *CacheStats
	mu        sync.RWMutex
}

// CacheStats 缓存统计
type CacheStats struct {
	Hits        int64 `json:"hits"`
	Misses      int64 `json:"misses"`
	L1Hits      int64 `json:"l1_hits"`
	L2Hits      int64 `json:"l2_hits"`
	Sets        int64 `json:"sets"`
	Deletes     int64 `json:"deletes"`
	Evictions   int64 `json:"evictions"`
}

// NewCacheManager 创建缓存管理器
func NewCacheManager(cache *MultiLevelCache) *CacheManager {
	return &CacheManager{
		cache: cache,
		stats: &CacheStats{},
	}
}

// Get 获取缓存值（带统计）
func (cm *CacheManager) Get(key string) (interface{}, bool) {
	value, hit := cm.cache.Get(key)
	
	cm.mu.Lock()
	if hit {
		cm.stats.Hits++
	} else {
		cm.stats.Misses++
	}
	cm.mu.Unlock()
	
	return value, hit
}

// Set 设置缓存值（带统计）
func (cm *CacheManager) Set(key string, value interface{}, ttl time.Duration) error {
	err := cm.cache.Set(key, value, ttl)
	
	cm.mu.Lock()
	cm.stats.Sets++
	cm.mu.Unlock()
	
	return err
}

// Delete 删除缓存值（带统计）
func (cm *CacheManager) Delete(key string) error {
	err := cm.cache.Delete(key)
	
	cm.mu.Lock()
	cm.stats.Deletes++
	cm.mu.Unlock()
	
	return err
}

// GetStats 获取缓存统计
func (cm *CacheManager) GetStats() CacheStats {
	cm.mu.RLock()
	defer cm.mu.RUnlock()
	return *cm.stats
}

// GetHitRate 获取命中率
func (cm *CacheManager) GetHitRate() float64 {
	cm.mu.RLock()
	defer cm.mu.RUnlock()
	
	total := cm.stats.Hits + cm.stats.Misses
	if total == 0 {
		return 0
	}
	return float64(cm.stats.Hits) / float64(total)
}

// CacheWarmer 缓存预热器
type CacheWarmer struct {
	cache   *CacheManager
	db      *gorm.DB
	workers int
}

// NewCacheWarmer 创建缓存预热器
func NewCacheWarmer(cache *CacheManager, db *gorm.DB, workers int) *CacheWarmer {
	return &CacheWarmer{
		cache:   cache,
		db:      db,
		workers: workers,
	}
}

// WarmupStudentCache 预热学生缓存
func (cw *CacheWarmer) WarmupStudentCache() error {
	// 获取热点数据
	var students []Student
	err := cw.db.Where("deleted_at IS NULL").
		Order("created_at DESC").
		Limit(1000). // 预热最近的1000个学生
		Find(&students).Error
	if err != nil {
		return err
	}
	
	// 并发预热
	workerPool := NewWorkerPool(cw.workers, len(students))
	workerPool.Start()
	defer workerPool.Stop()
	
	for _, student := range students {
		student := student // 避免闭包问题
		job := &CacheWarmupJob{
			cache:   cw.cache,
			student: student,
		}
		workerPool.Submit(job)
	}
	
	return nil
}

// CacheWarmupJob 缓存预热任务
type CacheWarmupJob struct {
	cache   *CacheManager
	student Student
}

// Execute 执行预热任务
func (cwj *CacheWarmupJob) Execute() error {
	key := fmt.Sprintf("student:%d", cwj.student.ID)
	return cwj.cache.Set(key, cwj.student, time.Hour)
}
```

## 11.5 网络优化

### HTTP优化

**文件路径：** `optimizations/http.go`

```go
package optimizations

import (
	"compress/gzip"
	"io"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
)

// CompressionMiddleware 压缩中间件
func CompressionMiddleware() gin.HandlerFunc {
	return gin.HandlerFunc(func(c *gin.Context) {
		// 检查客户端是否支持gzip
		if !strings.Contains(c.GetHeader("Accept-Encoding"), "gzip") {
			c.Next()
			return
		}
		
		// 检查内容类型是否需要压缩
		contentType := c.GetHeader("Content-Type")
		if !shouldCompress(contentType) {
			c.Next()
			return
		}
		
		// 设置压缩响应头
		c.Header("Content-Encoding", "gzip")
		c.Header("Vary", "Accept-Encoding")
		
		// 创建gzip writer
		gzipWriter := gzip.NewWriter(c.Writer)
		defer gzipWriter.Close()
		
		// 替换writer
		c.Writer = &gzipResponseWriter{
			ResponseWriter: c.Writer,
			gzipWriter:     gzipWriter,
		}
		
		c.Next()
	})
}

// shouldCompress 判断是否应该压缩
func shouldCompress(contentType string) bool {
	compressibleTypes := []string{
		"text/",
		"application/json",
		"application/javascript",
		"application/xml",
		"image/svg+xml",
	}
	
	for _, t := range compressibleTypes {
		if strings.Contains(contentType, t) {
			return true
		}
	}
	return false
}

// gzipResponseWriter gzip响应写入器
type gzipResponseWriter struct {
	gin.ResponseWriter
	gzipWriter *gzip.Writer
}

// Write 写入数据
func (grw *gzipResponseWriter) Write(data []byte) (int, error) {
	return grw.gzipWriter.Write(data)
}

// WriteString 写入字符串
func (grw *gzipResponseWriter) WriteString(s string) (int, error) {
	return grw.gzipWriter.Write([]byte(s))
}

// ConnectionPoolMiddleware 连接池中间件
func ConnectionPoolMiddleware() gin.HandlerFunc {
	return gin.HandlerFunc(func(c *gin.Context) {
		// 设置Keep-Alive
		c.Header("Connection", "keep-alive")
		c.Header("Keep-Alive", "timeout=60, max=1000")
		
		c.Next()
	})
}

// ETagMiddleware ETag缓存中间件
func ETagMiddleware() gin.HandlerFunc {
	return gin.HandlerFunc(func(c *gin.Context) {
		// 只对GET请求启用ETag
		if c.Request.Method != "GET" {
			c.Next()
			return
		}
		
		// 创建ETag响应写入器
		etagWriter := &etagResponseWriter{
			ResponseWriter: c.Writer,
			request:        c.Request,
		}
		c.Writer = etagWriter
		
		c.Next()
		
		// 处理ETag
		etagWriter.handleETag()
	})
}

// etagResponseWriter ETag响应写入器
type etagResponseWriter struct {
	gin.ResponseWriter
	request *http.Request
	body    []byte
}

// Write 写入数据
func (erw *etagResponseWriter) Write(data []byte) (int, error) {
	erw.body = append(erw.body, data...)
	return len(data), nil
}

// handleETag 处理ETag
func (erw *etagResponseWriter) handleETag() {
	if len(erw.body) == 0 {
		return
	}
	
	// 生成ETag
	etag := fmt.Sprintf(`"%x"`, md5.Sum(erw.body))
	
	// 检查If-None-Match头
	ifNoneMatch := erw.request.Header.Get("If-None-Match")
	if ifNoneMatch == etag {
		erw.ResponseWriter.WriteHeader(http.StatusNotModified)
		return
	}
	
	// 设置ETag头并写入响应
	erw.ResponseWriter.Header().Set("ETag", etag)
	erw.ResponseWriter.Write(erw.body)
}
```